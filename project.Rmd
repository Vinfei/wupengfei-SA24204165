```{r}
DebiasedLasso <- function(X,y,alpha,lambda = NULL) {
  # 各变量含义：
  # `X`: 设计矩阵（样本 × 特征矩阵），包含所有的输入变量。
  # `y`: 响应变量（目标变量），与设计矩阵 X 关联。
  # `alpha`: 显著性水平，用于计算置信区间
  # `lambda`: 正则化参数（LASSO 回归的惩罚项系数），如果未提供，将根据理论公式计算。
  
  # 检查维度
  n <- nrow(X)
  p <- ncol(X)
  
  # 标准化设计矩阵
  X_scaled <- scale(X)
  
  # 默认正则化参数，如果未提供则根据理论公式计算
  if (is.null(lambda)) {
    lambda <- sqrt(2 * log(p) / n)
  }
  
  # 使用 glmnet 进行 LASSO 回归以获取初始估计值
  lasso_fit <- glmnet::glmnet(X_scaled, y, alpha = 1, lambda = lambda, intercept = FALSE, standardize = FALSE)
  lasso_coef <- as.numeric(coef(lasso_fit, s = lambda))[-1] # 去掉截距
  
  # 估计残差和噪声水平
  residuals <- y - X_scaled %*% lasso_coef
  sigma_hat <- sqrt(sum(residuals^2) / (n - sum(lasso_coef != 0)))
  
  # 计算 XtX 并进行 Cholesky 分解
  XtX <- crossprod(X_scaled) / n
  M <- chol2inv(chol(XtX + diag(lambda, p))) 

  # 去偏估计
  debiased_coef <- lasso_coef + M %*% t(X_scaled) %*% residuals / n
  
  # 计算每个系数的标准误差
  se <- sqrt(diag(M) * sigma_hat^2 / n)
  
  # 置信区间
  z_critical <- qnorm(1 - alpha / 2)
  ci_lower <- debiased_coef - z_critical * se
  ci_upper <- debiased_coef + z_critical * se
  
  # 计算 p 值
  p_values <- 2 * (1 - pnorm(abs(debiased_coef / se)))
  
  # 返回结果
  return(list(
    coefficients = debiased_coef,
    lasso_coefficients = lasso_coef,
    standard_errors = se,
    confidence_intervals = data.frame(lower = ci_lower, upper = ci_upper),
    p_values = p_values,
    noise_sd = sigma_hat
  ))
}

# 示例用法
set.seed(123)
n <- 1000  # 样本量
p <- 200  # 特征数量
s0 <- 15  # 非零系数个数
b <- 1    # 非零系数值

# 生成设计矩阵和响应变量
X <- matrix(rnorm(n * p), n, p)
true_beta <- c(rep(b, s0), rep(0, p - s0))
y <- X %*% true_beta + rnorm(n, sd = 0.5)

# 调用函数并打印结果
result <- DebiasedLasso(X, y, 0.05)
print(result$coefficients)
print(result$confidence_intervals)
```

